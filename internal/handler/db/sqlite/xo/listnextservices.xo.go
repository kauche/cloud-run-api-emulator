package xo

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// ListNextServices represents a row from 'list_next_services'.
type ListNextServices struct {
	Parent      string `json:"parent"`      // parent
	Name        string `json:"name"`        // name
	Description string `json:"description"` // description
	UID         string `json:"uid"`         // uid
	URI         string `json:"uri"`         // uri
	Generation  int64  `json:"generation"`  // generation
	CreatedAt   Time   `json:"created_at"`  // created_at
}

// ListNextServicesByParentCreatedAtNameLimit runs a custom query, returning results as [ListNextServices].
func ListNextServicesByParentCreatedAtNameLimit(ctx context.Context, db DB, parent, created_at, name string, limit int32) ([]*ListNextServices, error) {
	// query
	const sqlstr = `SELECT` +
		`    parent,` +
		`    name,` +
		`    description,` +
		`    uid,` +
		`    uri,` +
		`    generation,` +
		`    created_at` +
		`  FROM services` +
		`  WHERE` +
		`    parent = $1 AND` +
		`    created_at <= $2 AND` +
		`    (created_at < $2 OR name > $3)` +
		`  ORDER BY` +
		`    created_at DESC,` +
		`    parent ASC,` +
		`    name ASC` +
		`  LIMIT` +
		`    $4;`
	// run
	logf(sqlstr, parent, created_at, name, limit)
	rows, err := db.QueryContext(ctx, sqlstr, parent, created_at, name, limit)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*ListNextServices
	for rows.Next() {
		var lns ListNextServices
		// scan
		if err := rows.Scan(&lns.Parent, &lns.Name, &lns.Description, &lns.UID, &lns.URI, &lns.Generation, &lns.CreatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &lns)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
